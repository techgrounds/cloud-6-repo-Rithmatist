from aws_cdk.aws_elasticloadbalancingv2 import SslPolicy
import aws_cdk.aws_elasticloadbalancingv2 as elbv2
from aws_cdk.aws_s3_assets import Asset
import aws_acm_certified as acm
import aws_cdk as cdk
from constructs import Construct
from aws_cdk import (
    aws_autoscaling as autoscaling,
    aws_ec2 as ec2,
)


class AutoScalingElbStack(cdk.NestedStack):
    def __init__(self, scope: Construct, id: str, vpc: ec2.Vpc, **kwargs) -> None:
        super().__init__(scope, id, **kwargs)

        environments = self.node.try_get_context("ENVIRONMENTS")
        wb_sg_environment = environments.get("webserver_security_group")
        wb_sg_name = wb_sg_environment.get("name")
        wb_sg_description = wb_sg_environment.get("description")
        wb_sg_ob = wb_sg_environment.get("allow_all_outbound")

        web_instance_environment = environments.get("webserver_instance")
        web_instance_name = web_instance_environment.get("name")
        web_instance_type = web_instance_environment.get("instance_type")
        web_instance_root = web_instance_environment.get("root_device_directory")
        web_instance_size = web_instance_environment.get("volume_size")
        web_instance_encrypt = web_instance_environment.get("encrypted_volume")
        web_instance_asset = web_instance_environment.get("asset_bucket")
        web_instance_path = web_instance_environment.get("asset_path")
        web_instance_region = web_instance_environment.get("asset_region")

        lb_environment = environments.get("LoadBalancer")
        lb_name = lb_environment.get("name")
        lb_internet_facing = lb_environment.get("internet_facing")
        lb_listeners_name = lb_environment.get("listener_name")
        lb_listeners_port = lb_environment.get("listener_port")
        lb_redirect_source_port = lb_environment.get("redirect_source_port")
        lb_redirect_target_port = lb_environment.get("redirect_target_port")
        lb_target_name = lb_environment.get("target_name")
        lb_target_port = lb_environment.get("target_port")
        lb_cpu_utilization_name = lb_environment.get("cpu_utilization_name")
        lb_target_utilization_percent = lb_environment.get("target_utilization_percent")

        self.Webserver_sg = ec2.SecurityGroup(
            self, wb_sg_name,
            vpc=vpc,
            description=wb_sg_description,
            allow_all_outbound=wb_sg_ob
        )

        # Create a key pair for the webserver.

        aws_linux = ec2.MachineImage.latest_amazon_linux(
            generation=ec2.AmazonLinuxGeneration.AMAZON_LINUX_2,
            edition=ec2.AmazonLinuxEdition.STANDARD,
            virtualization=ec2.AmazonLinuxVirt.HVM,
            storage=ec2.AmazonLinuxStorage.GENERAL_PURPOSE,
        )

        self.asg = autoscaling.AutoScalingGroup(
            self, web_instance_name,
            instance_type=ec2.InstanceType(web_instance_type),
            machine_image=aws_linux,
            security_group=self.Webserver_sg,
            vpc=vpc,
            # key_name="web_key",
            block_devices=[autoscaling.BlockDevice(
                device_name=web_instance_root,
                volume=autoscaling.BlockDeviceVolume.ebs(web_instance_size,
                                                         encrypted=web_instance_encrypt
                                                         )
            )
            ],
            desired_capacity=1,
            min_capacity=1,
            max_capacity=3,
        )

        assets = Asset(self, web_instance_asset,
                       path=web_instance_path
                       )

        Local_path = self.asg.user_data.add_s3_download_command(
            bucket=assets.bucket,
            bucket_key=assets.s3_object_key,
            region=web_instance_region,
        )

        self.asg.user_data.add_execute_file_command(
            file_path=Local_path
        )

        lb = elbv2.ApplicationLoadBalancer(
            self,
            lb_name,
            vpc=vpc,
            internet_facing=lb_internet_facing)

        # assign private self signed certificate to the load balancer that is generated by a custom function.

        listener_certificate = elbv2.ListenerCertificate.from_arn(acm.generated_certificate())

        # add listener to the load balancer.

        listener = lb.add_listener(
            lb_listeners_name,
            port=lb_listeners_port,
            certificates=[listener_certificate],
            ssl_policy=SslPolicy.RECOMMENDED
        )

        # add redirect to the load balancer.

        lb.add_redirect(
            source_port=lb_redirect_source_port,
            target_port=lb_redirect_target_port
        )

        # add target group to the load balancer.

        listener.add_targets(
            lb_target_name,
            port=lb_target_port,
            targets=[self.asg]
        )

        # add listener connections to the load balancer.

        listener.connections.allow_default_port_from_any_ipv4("Open to the world")

        # add scaling rule on cpu utilization.

        self.asg.scale_on_cpu_utilization(
            lb_cpu_utilization_name,
            target_utilization_percent=lb_target_utilization_percent
        )
